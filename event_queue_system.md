# Event Queue System (Hybrid Model)

## Overview
This system provides a structured way to process **events** in a game loop using a **hybrid queue** model. It ensures that both **rules-driven events** (those that must always happen) and **triggered events** (those that react to conditions) are executed in a **deterministic order**, while also supporting events that may take multiple steps (animations, player input, async operations).

The Event Queue System prevents race conditions, ensures events complete fully before the next begins, and makes complex game flows predictable and easy to extend.

---

## Key Concepts

### Event
An **Event** is a discrete unit of game logic.  
Each Event has:
- **Type**: what kind of event it is  
- **Source**: who/what caused it  
- **Target(s)**: who/what is affected  
- **Payload**: data required to resolve the event  
- **State**: (`Pending`, `Resolving`, `Waiting`, `Complete`)  

### Event Queues
Two queues manage event flow:

1. **Rules Queue**  
   Contains **mandatory events** generated by the game’s core systems (phases, timers, scripted rules).  
   These must always resolve before anything else.

2. **Trigger Queue**  
   Contains **reactive events** generated by other events (abilities, conditional reactions, scripted responses).  
   These only resolve after the current rules event has finished.

---

## Event Lifecycle
1. **Pending** → Event is created and enqueued.  
2. **Resolving** → Event’s effect has started.  
   - Simple events complete immediately.  
   - Complex events may wait on input, animations, or async processes.  
3. **Waiting** → (optional) State used if external factors must finish first.  
4. **Complete** → Event is finished, triggers are checked, and the next event begins.  

---

## Processing Loop
1. If no event is currently resolving:
   - Dequeue from **Rules Queue** if available.  
   - Otherwise, dequeue from **Trigger Queue**.  
2. Begin resolving the event (`StartResolving`).  
3. Update it each frame/tick until it marks itself **Complete**.  
4. Once complete:
   - Check if it caused new triggered events.  
   - Enqueue those into the **Trigger Queue**.  
   - Move on to the next available event.  
5. When both queues are empty, the system is idle until new events are added.

---

## Benefits
- **Deterministic execution** → events always resolve in a predictable order.  
- **Safe sequencing** → no new event begins until the previous one has fully finished.  
- **Supports synchronous and asynchronous operations** →  
  - Fast effects (damage, state changes) resolve instantly.  
  - Long effects (animations, choices, coroutines) persist until done.  
- **Extensible** → new event types and triggers can be added without modifying the core system.  
- **Game-agnostic** → works for card games, RPGs, RTS, simulations, or any system where discrete actions and reactions must resolve in order.

---

## Example Use Cases
- **Card Game**  
  “Start turn” (rules) → “Draw card” → “On draw” triggers → resolve life gain → resolve damage reaction.  

- **RPG**  
  “Attack” (rules) → “On hit” trigger → poison effect → damage over time tick.  

- **Simulation**  
  “Day starts” (rules) → “Weather changes” → “On rain” trigger → crops grow.  

---

## What This Accomplishes
- Decouples **game rules** from **game reactions**.  
- Provides a unified, predictable flow for **all game events**.  
- Allows both **instant effects** and **long-running effects** to coexist without breaking the sequence.  
- Lays the groundwork for robust systems like phases, triggers, conditional logic, and async operations.  
