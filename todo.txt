- more dialog
- pause screen
- combat music
- sound effects
- improved cursor feedback
- position battle entities spawn away from top left corner (parallax layer issue, not sure why) - TRICKY
- equipment tooltip overhaul
- more animations / fix existing
- parallax background
- set music correctly for each scene
- play card animation
- gain rewards animation



Prompts - 

enemy attack display - update text for different types of conditinos (one card, tow cards, etc)
"if this attack (deals damage, is not blocked by X cards) - [effect]"

abandon quest screen needs to prevent actions "behind"

card idea - spend aegis

cards level up - playing them grants +X exp and finishing a quest gives them all +Y exp; need to figure out smart way of implementing upgraded version

cancel button in pay cost overlay doest work with mouse; X is not positoined correctly

card hand hitbox is wonky

defile and tarnish effects (enemy attacks that mutate blocked cards - exhaust on next block / use)

on hit - exhaust top card of player's deck

on hit - top card gains burn 1

on hit - card becomes colorless

cardtooltip not being correctly removed for blocked cards, can see from opening discard modal (only happens for mouse controls?)

Convert desert background to shader
Generate shield shader and helper; create shield display system that keys off existence of having shield passive.

medals - 

whenever you block with a black card, gain X aggresion
start the battle with 1 power
whenever you block with a black card, shuffle a random non-black card into your deck (too strong)

tribulations - 

start combat with intimidated

equipment - 

remove X burn
heal X
change the color of a card in your hand to black/white/red
gain x power this turn
draw a card
prevent the next mill effect
mill x cards - put each red/white/black into your hand
remove a shield from the enemy

cards - 

gain X power this turn
deal X damage Y times, where Y is your courage. Lose all courage.

Shield shader:
// Shield shader reconstructed from screenshots
// Author: reconstructed by ChatGPT (based on images provided)
//
// Shadertoy uniforms expected:
// uniform vec3      iResolution;
// uniform float     iTime;
// uniform sampler2D iChannel0;

#ifdef GL_ES
precision mediump float;
#endif

// ---------- Parameters (from screenshots) ----------
const float SHIELD_RADIUS       = 0.4;   // Overall shield size
const float SHIELD_THICKNESS    = 0.03;  // Width of the shield border
const float INNER_FADE          = 0.02;  // Fade distance for inner shield area

// Outer Ring Distortion
const float RING_DISTORT_AMOUNT = 0.03;  // How much the ring warps
const float RING_DISTORT_FREQ   = 4.0;   // Frequency of ring distortion
const float RING_DISTORT_SPEED  = 0.5;   // Speed of ring warping animation
const float RING_NOISE_SCALE    = 100.0;  // Scale of noise detail on ring

// Electric Shock Effects
const float SHOCK_COUNT        = 0.0;  // Number of shock bolts around ring
const float SHOCK_SPEED        = 0.0;   // Speed of shock animation
const float SHOCK_INTENSITY    = 2.5;   // Brightness of shock bolts
const float SHOCK_WIDTH        = 0.015; // Width of shock bolts
const float SHOCK_JAGGEDNESS   = 15.0;  // How jagged the bolts are
const float SHOCK_FREQUENCY    = 2.0;   // How often shocks appear

// Hexagon Pattern
const float HEX_SCALE       = 0.0;  // Density of hexagons (higher = more hexagons)
const float HEX_OUTER_SIZE  = 0.06; // Outer edge of hexagon lines
const float HEX_INNER_SIZE  = 0.01; // Inner edge of hexagon lines
const float HEX_CORE_SIZE   = 0.02; // Core size of hexagon lines

// Animation Speeds
const float SCAN_SPEED   = 0.0; // speed of vertical scan lines
const float PULSE_SPEED  = 1.0; // shield pulsing speed
const float WAVE_SPEED   = 0.0; // energy wave speed
const float BUBBLE_SPEED = 0.0; // bubble wobble animation

// Animation Intensities
const float SCAN_FREQUENCY   = 3.0;
const float SCAN_POWER       = 3.0;
const float WAVE_FREQUENCY   = 20.0;
const float WAVE_POWER       = 3.0;
const float PULSE_INTENSITY  = 1.3;
const float SCAN_BLEND       = 0.5;
const float SCAN_MODULATION  = 0.5;

// Bubble Distortion
const float BUBBLE_STRENGTH   = 0.15;
const float BUBBLE_FREQUENCY  = 8.0;
const float BUBBLE_DETAIL     = 3.0;
const float BUBBLE_FADE_START = 0.3;
const float BUBBLE_FADE_END   = 0.38;
const float REFRACTION_STRENGTH = 0.04;
const float DISTORTION_FALLOFF   = 0.05;

// Colors (vec3)
const vec3 SHIELD_COLOR = vec3(0.3, 0.0, 0.0);  // Main shield color (cyan)
const vec3 HEX_COLOR    = vec3(0.3, 1.0, 1.0);  // Hexagon line color (bright cyan)
const vec3 BUBBLE_TINT  = vec3(1, 0.9, 1.0);  // Bubble surface tint
const vec3 SHOCK_COLOR  = vec3(0.6, 1.0, 1.0);  // Electric shock color

// Brightness Multipliers
const float EDGE_BRIGHTNESS    = 2.0;
const float HEX_BRIGHTNESS     = 0.8;
const float WAVE_BRIGHTNESS    = 0.1;
const float FRESNEL_BRIGHTNESS = 1.5;
const float FRESNEL_POWER      = 2.0;
const float BUBBLE_HIGHLIGHT   = 0.4;

// Background dimming & opacity
const float BG_DIMMING   = 1.0;
const float SHIELD_OPACITY = 0.7;

// ---------- Helper functions ----------
float hash(float n) {
    return fract(sin(n) * 43758.5453123);
}

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}

// 2D value noise (smooth)
float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    // Smoothstep-like interpolation
    f = f * f * (3.0 - 2.0 * f);
    float a = hash(i + vec2(0.0,0.0));
    float b = hash(i + vec2(1.0,0.0));
    float c = hash(i + vec2(0.0,1.0));
    float d = hash(i + vec2(1.0,1.0));
    return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
}

// rotate 2D
mat2 rot(float a) {
    float s = sin(a), c = cos(a);
    return mat2(c, -s, s, c);
}

// Signed distance to hexagon-like grid cell (approx)
vec2 hexgrid(vec2 p, float scale) {
    // Transform to hex grid coordinates
    // Based on screenshots: r = vec2(1.0, 1.732)
    vec2 r = vec2(1.0, 1.732);
    float h = r.x * 0.5; // use r.x (1.0) * 0.5
    vec2 a = mod(p, r) - h;
    vec2 b = mod(p - vec2(h,0.0), r) - h;
    vec2 gv = (length(a) < length(b)) ? a : b;
    return gv;
}

// ---------- Main shader ----------
void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y; // normalized -1..1 preserving aspect
    vec2 screenUV = fragCoord.xy / iResolution.xy;

    // Polar coordinates
    float angle = atan(uv.y, uv.x);
    float dist = length(uv);

    // --- Add organic distortion to shield radius (ring noise) ---
    float angleNoise = noise(vec2(angle * RING_DISTORT_FREQ + iTime * RING_DISTORT_SPEED,
                                 dist * RING_NOISE_SCALE));
    float radiusDistort = angleNoise * RING_DISTORT_AMOUNT;
    float detailNoise = noise(vec2(angle * RING_NOISE_SCALE, dist * RING_NOISE_SCALE * 0.5));
    radiusDistort += detailNoise * RING_DISTORT_AMOUNT * 0.3;
    float distortedRadius = SHIELD_RADIUS + radiusDistort;

    // Distortion mask - inside the shield only
    float distortionMask = smoothstep(distortedRadius + DISTORTION_FALLOFF, distortedRadius - DISTORTION_FALLOFF, dist);

    // --- Electric shock bolts (ring) ---
    float shockEffect = 0.0;
    for (float i = 0.0; i < SHOCK_COUNT; i += 1.0) {
        float shockAngle = (i / SHOCK_COUNT) * 6.28318;
        float shockTime = iTime * SHOCK_SPEED + i * 0.5;
        float shockActive = step(0.7, sin(shockTime * SHOCK_FREQUENCY)); // step to gate activity
        // angle difference (wrap)
        float aDiff = angle - shockAngle;
        aDiff = atan(sin(aDiff), cos(aDiff));
        // jagged bolt effect
        float boltNoise = noise(vec2(dist * SHOCK_JAGGEDNESS, shockTime * 2.0 + i));
        float boltWidth = SHOCK_WIDTH * (1.0 + boltNoise * 0.5);
        float shock = exp(-abs(aDiff) / boltWidth) * shockActive;
        // inside ring only
        shock *= smoothstep(distortedRadius + SHIELD_THICKNESS, distortedRadius - SHIELD_THICKNESS * 0.5, dist);
        shockEffect += shock;
    }

    // --- Bubble distortion / surface ---
    float bubbleMask = smoothstep(BUBBLE_FADE_END, BUBBLE_FADE_START, dist);

    float bubbleWobble1 = sin(angle * BUBBLE_FREQUENCY + iTime * BUBBLE_SPEED) * 0.5 + 0.5;
    float bubbleWobble2 = sin(angle * BUBBLE_DETAIL - iTime * BUBBLE_SPEED * 0.7) * 0.5 + 0.5;
    float bubblePattern = bubbleWobble1 * 0.6 + bubbleWobble2 * 0.4;

    // Distort UV for hex sampling & bg refraction
    vec2 distortedUV = uv;
    vec2 normalDir = normalize(uv + vec2(0.001, 0.0));
    float distortAmount = bubblePattern * BUBBLE_STRENGTH * bubbleMask;
    distortedUV += normalDir * distortAmount * sin(iTime * 2.0 + dist * 10.0);

    // Refraction offset for background (only apply inside shield)
    vec2 refractionOffset = vec2(0.0);
    refractionOffset += normalDir * distortAmount * REFRACTION_STRENGTH;
    refractionOffset += normalDir * ((dist / SHIELD_RADIUS) * REFRACTION_STRENGTH * 0.5);
    refractionOffset += normalDir * radiusDistort * 0.5;
    refractionOffset *= distortionMask;

    // Sample background with masked refraction
    vec2 bgUV = screenUV + refractionOffset;
    vec3 background = texture(iChannel0, bgUV).rgb;

    // Dim background inside shield
    float shieldArea = smoothstep(distortedRadius + 0.05, distortedRadius - 0.05, dist);
    background *= mix(1.0, BG_DIMMING, shieldArea);

    // Create hexagonal pattern using distorted UV scaled by HEX_SCALE
    vec2 hexUV = distortedUV * HEX_SCALE;
    vec2 gv = hexgrid(hexUV, HEX_SCALE);
    float hexDist = length(gv);
    float hexLines = smoothstep(HEX_OUTER_SIZE, HEX_INNER_SIZE, hexDist) - smoothstep(HEX_INNER_SIZE, HEX_CORE_SIZE, hexDist);

    // Animated scan lines
    float scanLine = sin(hexUV.y * SCAN_FREQUENCY + iTime * SCAN_SPEED) * 0.5 + 0.5;
    scanLine = pow(scanLine, SCAN_POWER);

    // Energy pulse / wave
    float pulse = sin(iTime * PULSE_SPEED) * 0.5 + 0.5;
    float energyWave = sin(dist * WAVE_FREQUENCY - iTime * WAVE_SPEED) * 0.5 + 0.5;
    energyWave = pow(energyWave, WAVE_POWER);

    // Shield boundaries using distorted radius
    float shield = smoothstep(distortedRadius + SHIELD_THICKNESS, distortedRadius, dist) - smoothstep(distortedRadius, distortedRadius - SHIELD_THICKNESS, dist);

    // Inner shield area
    float innerShield = smoothstep(distortedRadius + INNER_FADE, distortedRadius - INNER_FADE, dist);

    // Combine effects
    float hexEffect = hexLines * innerShield * (SCAN_BLEND + scanLine * SCAN_MODULATION);
    float edgeGlow = shield * (1.0 + pulse * PULSE_INTENSITY);

    // Bubble surface highlights
    float bubbleHighlight = pow(bubblePattern, 2.0) * bubbleMask * BUBBLE_HIGHLIGHT;

    // Build shield color
    vec3 shieldCol = vec3(0.0);
    shieldCol += SHIELD_COLOR * edgeGlow * EDGE_BRIGHTNESS;
    shieldCol += HEX_COLOR * hexEffect * HEX_BRIGHTNESS;
    shieldCol += SHIELD_COLOR * energyWave * innerShield * WAVE_BRIGHTNESS;
    shieldCol += BUBBLE_TINT * bubbleHighlight;
    shieldCol += SHOCK_COLOR * shockEffect * SHOCK_INTENSITY;

    // Fresnel-like edge brightening
    float fresnel = pow(1.0 - abs(dist - distortedRadius) / SHIELD_THICKNESS, FRESNEL_POWER);
    shieldCol += SHIELD_COLOR * fresnel * FRESNEL_BRIGHTNESS;

    // Calculate shield alpha
    float shieldAlpha = (edgeGlow + hexEffect + bubbleHighlight + shockEffect) * SHIELD_OPACITY;
    shieldAlpha = clamp(shieldAlpha, 0.0, 1.0);

    // Blend shield onto background
    vec3 col = mix(background, shieldCol, shieldAlpha);

    // Output
    fragColor = vec4(col, 1.0);
}
